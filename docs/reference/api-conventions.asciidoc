[[api-conventions]]
= API 约定

[partintro]
--
*Elasticsearch* REST APIs 基于 <<modules-http,HTTP JSON 交互>> 。

除非特殊说明，本章约定适用于整个 REST API。

* <<multi-index>>
* <<date-math-index-names>>
* <<common-options>>
* <<url-access-control>>

--

[[multi-index]]
== 多重索引

多数引用 `index` 参数的 APIs 都支持多索引执行，使用简单的 `test1,test2,test3` 表示形式（或所有索引的 `_all` ）。
它也支持通配符，例如：`test*` 或 `*test` 或 `te*t` 或 `*test*` ，也包括 "exclude" （ `-` ）能力，例如：`test*,-test3` 。

所有多重索引 APIs 支持以下 url 查询字符串参数：

`ignore_unavailable`::

控制指定的索引不可用时是否忽略，这包括不存在或关闭的索引。可以指定为 `true` 或 `false` 。

`allow_no_indices`::

控制当通配符表达式未命中实际索引时是否失败。可以指定 `true` 或 `false` 。
例如，指定 `foo*` 通配符表达式而并没有以 `foo` 开头的索引，那么依赖此设置的请求会失败。
这个设置在 `_all` 、 `*` 或未指定索引时也适用。这个设置同样适用于别名，以防止别名指向关闭的索引。

`expand_wildcards`::

控制通配符表达式可以扩展到哪些具体索引。
如果指定为 `open` ，那么通配符表达式仅仅扩展为打开的索引，如果指定为 `closed` ，则通配符表达式仅仅扩展为关闭的索引。
也可以同时指定所有值（ `open,closed` ）扩展到所有索引。
+
如果指定为 `none` 那么通配符扩展将禁用，如果指定为 `all` 那么通配符表达式将扩展至所有索引（等同于指定 `open,closed` ）。

上述参数的默认设置取决于所使用的 api。

NOTE: 单索引 APIs， 例如 <<docs>> 和
<<indices-aliases,single-index `alias` APIs>> 不支持多重索引。

[[date-math-index-names]]
==  Date math 索引名称支持

Date math 索引名称解析可以让你搜索一段时间序列索引，而不是搜索所有时间序列索引然后过滤结果或维护别名。
限制搜索索引数减少了集群负载并提高了执行性能。例如，如果你在每天的日志中搜索错误，你可以使用 date math 名称模板将搜索天数限制为两天。

几乎所有 APIs 具有支持 date math 的 `index` 参数。

date math 索引名称采用以下形式：

[source,txt]
----------------------------------------------------------------------
<static_name{date_math_expr{date_format|time_zone}}>
----------------------------------------------------------------------

Where:

[horizontal]
`static_name`:: 名称的静态文本部分
`date_math_expr`:: 动态计算日期的动态 date math 表达式
`date_format`:: 计算日期呈现的可选格式。默认是 `YYYY.MM.dd`
`time_zone`:: 可选时区。默认是 `utc`

你必须将 date math 索引名表达式放在尖括号中，同时所有的特殊字符应该进行 URI 编码。例如：

[source,js]
----------------------------------------------------------------------
# GET /<logstash-{now/d}>/_search
GET /%3Clogstash-%7Bnow%2Fd%7D%3E/_search
{
  "query" : {
    "match": {
      "test": "data"
    }
  }
}
----------------------------------------------------------------------
// CONSOLE
// TEST[s/^/PUT logstash-2016.09.20\n/]
// TEST[s/now/2016.09.20||/]

[NOTE]
.date math 字符百分号编码
======================================================
用于日期舍入的特殊字符必须按如下方式 URI 编码：

[horizontal]
`<`:: `%3C`
`>`:: `%3E`
`/`:: `%2F`
`{`:: `%7B`
`}`:: `%7D`
`|`:: `%7C`
`+`:: `%2B`
`:`:: `%3A`
`,`:: `%2C`
======================================================

下例展示了对于给定当前 utc 时间为 2024 年 3 月 22 日中午不同格式的 date math 索引名和它们解析的最终索引名，

[options="header"]
|======
| Expression                                |Resolves to
| `<logstash-{now/d}>`                      | `logstash-2024.03.22`
| `<logstash-{now/M}>`                      | `logstash-2024.03.01`
| `<logstash-{now/M{YYYY.MM}}>`             | `logstash-2024.03`
| `<logstash-{now/M-1M{YYYY.MM}}>`          | `logstash-2024.02`
| `<logstash-{now/d{YYYY.MM.dd\|+12:00}}>`  | `logstash-2024.03.23`
|======

为了在索引名称模板中使用 `{` and `}` 字符，请使用反斜线 `\` 对其转义，例如：

 * `<elastic\\{ON\\}-{now/M}>` resolves to `elastic{ON}-2024.03.01`

下例展示了在 Logstash 索引中搜索过去三天的搜索请求，假设索引使用默认 Logstash 索引名格式，`logstash-YYYY.MM.dd` 。

[source,js]
----------------------------------------------------------------------
# GET /<logstash-{now/d-2d}>,<logstash-{now/d-1d}>,<logstash-{now/d}>/_search
GET /%3Clogstash-%7Bnow%2Fd-2d%7D%3E%2C%3Clogstash-%7Bnow%2Fd-1d%7D%3E%2C%3Clogstash-%7Bnow%2Fd%7D%3E/_search
{
  "query" : {
    "match": {
      "test": "data"
    }
  }
}
----------------------------------------------------------------------
// CONSOLE
// TEST[s/^/PUT logstash-2016.09.20\nPUT logstash-2016.09.19\nPUT logstash-2016.09.18\n/]
// TEST[s/now/2016.09.20||/]

[[common-options]]
== 公共选项

以下选项适用于所有 REST APIs。

[float]
=== Pretty 结果

当在任何请求后追加 `?pretty=true` ，JSON 将优雅地格式化（仅用于调试！）。
另一个选项是设置 `?format=yaml` ，这将使结果（有时）以更可读的 yaml 格式返回。


[float]
=== 输出人类可读

返回适合人类（例如 `"exists_time": "1h"` 或 `"size": "1kb"` ）和计算机（例如 `"exists_time_in_millis": 3600000` 或 `"size_in_bytes": 1024` ）的统计格式。
人类可读值可以通过在查询字符串添加 `?human=false` 关闭。
这在统计结果是被监控工具消费而不是被人类消费时很有意义。默认 `human` 标志是 `false` 。

[[date-math]]
[float]
=== Date Math

多数接收格式化日期值的参数 -- 例如 <<query-dsl-range-query,range queries>> `range` 查询中的 `gt` 和 `lt` ，
或者 <<search-aggregations-bucket-daterange-aggregation,`daterange` aggregations>> 中的 `from` 和 `to` --  可以理解 date maths。

以 anchor date 开头的表达式，可以是 `now` ，也可以是以 `||` 结尾的 date 字符串。该 anchor date 可以选择性地跟一个或多个数学表达式：

* `+1h` - 加一小时
* `-1d` - 减一小时
* `/d`  - 向下舍入到最近一天

支持的时间单位不同于持续时间所支持的时间单位。
这些单位是：

[horizontal]
`y`:: years
`M`:: months
`w`:: weeks
`d`:: days
`h`:: hours
`H`:: hours
`m`:: minutes
`s`:: seconds

假设 `now` 是 `2001-01-01 12:00:00` ，以下是一些例子：

`now+1h`:: `now` 在 milliseconds 加一小时。 解析为：`2001-01-01 13:00:00`
`now-1h`:: `now` 在 milliseconds 减一小时。 解析为：`2001-01-01 11:00:00`
`now-1h/d`:: `now` 在 milliseconds 向下舍入为 UTC 00:00。解析为：`2001-01-01 00:00:00`
 `2001-01-01\|\|+1M/d`:: `now` 在 milliseconds 加一个月。解析为：`2001-02-01 00:00:00`

[float]
[[common-options-response-filtering]]
=== 响应过滤

所有的 REST APIs 接收一个可以减少 Elasticsearch 响应的 `filter_path` 参数。
这个参数以逗号分隔点符号过滤表达式：

[source,js]
--------------------------------------------------
GET /_search?q=elasticsearch&filter_path=took,hits.hits._id,hits.hits._score
--------------------------------------------------
// CONSOLE
// TEST[setup:twitter]

响应：

[source,js]
--------------------------------------------------
{
  "took" : 3,
  "hits" : {
    "hits" : [
      {
        "_id" : "0",
        "_score" : 1.6375021
      }
    ]
  }
}
--------------------------------------------------
// TESTRESPONSE[s/"took" : 3/"took" : $body.took/]
// TESTRESPONSE[s/1.6375021/$body.hits.hits.0._score/]

这同样支持以 `*` 通配符匹配字段名的任何字段：

[source,sh]
--------------------------------------------------
GET /_cluster/state?filter_path=metadata.indices.*.stat*
--------------------------------------------------
// CONSOLE
// TEST[s/^/PUT twitter\n/]

响应：

[source,sh]
--------------------------------------------------
{
  "metadata" : {
    "indices" : {
      "twitter": {"state": "open"}
    }
  }
}
--------------------------------------------------
// TESTRESPONSE

同时 `**` 通配符可以用于包括不知道确切路径的字段。例如，我们可以用该请求返回每个段的 Lucene 版本：

[source,js]
--------------------------------------------------
GET /_cluster/state?filter_path=routing_table.indices.**.state
--------------------------------------------------
// CONSOLE
// TEST[s/^/PUT twitter\n/]

响应：

[source,js]
--------------------------------------------------
{
  "routing_table": {
    "indices": {
      "twitter": {
        "shards": {
          "0": [{"state": "STARTED"}, {"state": "UNASSIGNED"}],
          "1": [{"state": "STARTED"}, {"state": "UNASSIGNED"}],
          "2": [{"state": "STARTED"}, {"state": "UNASSIGNED"}],
          "3": [{"state": "STARTED"}, {"state": "UNASSIGNED"}],
          "4": [{"state": "STARTED"}, {"state": "UNASSIGNED"}]
        }
      }
    }
  }
}
--------------------------------------------------
// TESTRESPONSE

同样可以使用字符 `-` 前缀过滤器排除一个或多个字段：

[source,js]
--------------------------------------------------
GET /_count?filter_path=-_shards
--------------------------------------------------
// CONSOLE
// TEST[setup:twitter]

响应：

[source,js]
--------------------------------------------------
{
  "count" : 5
}
--------------------------------------------------
// TESTRESPONSE

为了更多的控制，inclusive 和 exclusive 过滤器可以组合在同一个表达式。
在这种情况下，结果将首先使用 exclusive filters，并使用 inclusive filters 再次过滤：

[source,js]
--------------------------------------------------
GET /_cluster/state?filter_path=metadata.indices.*.state,-metadata.indices.logstash-*
--------------------------------------------------
// CONSOLE
// TEST[s/^/PUT index-1\nPUT index-2\nPUT index-3\nPUT logstash-2016.01\n/]

响应：

[source,js]
--------------------------------------------------
{
  "metadata" : {
    "indices" : {
      "index-1" : {"state" : "open"},
      "index-2" : {"state" : "open"},
      "index-3" : {"state" : "open"}
    }
  }
}
--------------------------------------------------
// TESTRESPONSE

注意 Elasticsearch 有时直接返回字段原始值，例如 `_source` 字段。
如果你需要过滤 `_source` 字段，你应该考虑以下方式让已有的 `_source` 参数
（更多细节请参考 <<get-source-filtering,Get API>> ）与 `filter_path` 参数相结合：

[source,js]
--------------------------------------------------
POST /library/book?refresh
{"title": "Book #1", "rating": 200.1}
POST /library/book?refresh
{"title": "Book #2", "rating": 1.7}
POST /library/book?refresh
{"title": "Book #3", "rating": 0.1}
GET /_search?filter_path=hits.hits._source&_source=title&sort=rating:desc
--------------------------------------------------
// CONSOLE

[source,js]
--------------------------------------------------
{
  "hits" : {
    "hits" : [ {
      "_source":{"title":"Book #1"}
    }, {
      "_source":{"title":"Book #2"}
    }, {
      "_source":{"title":"Book #3"}
    } ]
  }
}
--------------------------------------------------
// TESTRESPONSE


[float]
=== 扁平设置

`flat_settings` 标志影响设置列表的呈现形式。当 `flat_settings` 标志为 `true` 设置将
以扁平格式返回：

[source,js]
--------------------------------------------------
GET twitter/_settings?flat_settings=true
--------------------------------------------------
// CONSOLE
// TEST[setup:twitter]

响应：

[source,js]
--------------------------------------------------
{
  "twitter" : {
    "settings": {
      "index.number_of_replicas": "1",
      "index.number_of_shards": "1",
      "index.creation_date": "1474389951325",
      "index.uuid": "n6gzFZTgS664GUfx0Xrpjw",
      "index.version.created": ...,
      "index.provided_name" : "twitter"
    }
  }
}
--------------------------------------------------
// TESTRESPONSE[s/1474389951325/$body.twitter.settings.index\\\\.creation_date/]
// TESTRESPONSE[s/n6gzFZTgS664GUfx0Xrpjw/$body.twitter.settings.index\\\\.uuid/]
// TESTRESPONSE[s/"index.version.created": \.\.\./"index.version.created": $body.twitter.settings.index\\\\.version\\\\.created/]

当 `flat_settings` 标志为 `false` ，设置将返回更适合人类阅读的格式化结构：

[source,js]
--------------------------------------------------
GET twitter/_settings?flat_settings=false
--------------------------------------------------
// CONSOLE
// TEST[setup:twitter]

响应：

[source,js]
--------------------------------------------------
{
  "twitter" : {
    "settings" : {
      "index" : {
        "number_of_replicas": "1",
        "number_of_shards": "1",
        "creation_date": "1474389951325",
        "uuid": "n6gzFZTgS664GUfx0Xrpjw",
        "version": {
          "created": ...
        },
        "provided_name" : "twitter"
      }
    }
  }
}
--------------------------------------------------
// TESTRESPONSE[s/1474389951325/$body.twitter.settings.index.creation_date/]
// TESTRESPONSE[s/n6gzFZTgS664GUfx0Xrpjw/$body.twitter.settings.index.uuid/]
// TESTRESPONSE[s/"created": \.\.\./"created": $body.twitter.settings.index.version.created/]

默认 `flat_settings` 为 `false` 。

[float]
=== 参数

Rest 参数 （当使用 HTTP，映射为 HTTP URL 参数）(when using HTTP, map to HTTP URL parameters）遵循使用下划线框的约定。

[float]
=== 布尔值

所有 REST APIs 参数（请求参数和 JSON 体）仅支持 "false" 作为 `false` 值和 "true" 作为 `true` 值。
所有其他值将产生一个错误。

[float]
=== 数值

所有 REST APIs 都支持在支持本机 JSON 数字类型的前提下提供编号参数作为字符串。

[[time-units]]
[float]
=== 时间单位

每当需要指定持续时间时，例如 `timeout` 参数，持续时间必须指定单位，比如 `2d` 为 2 天。支持的单位为：

[horizontal]
`d`::       days
`h`::       hours
`m`::       minutes
`s`::       seconds
`ms`::      milliseconds
`micros`::  microseconds
`nanos`::   nanoseconds

[[byte-units]]
[float]
=== 字节大小单位

当需要指定数据字节大小时，例如设置 buffer 大小参数，该值必须指定单位，例如 `10kb` 为 10 kb。
注意这些单位使用 1024 幂，所以 `1kb` 等于 1024 字节。支持的单位有：

[horizontal]
`b`::   Bytes
`kb`::  Kilobytes
`mb`::  Megabytes
`gb`::  Gigabytes
`tb`::  Terabytes
`pb`::  Petabytes

[[size-units]]
[float]
=== 无单位数

无单位数意味着它们不需要类似 "bytes" 或 "Hertz" 或 "meter" 或 "long tonne" 的 "单位"。

如果这些数很大我们将用 10m 替代 10,000,000 或 7k 替代 7,000 输出。
我们仍将用 87 输出 87。以下是支持的乘数：

[horizontal]
``::   Single
`k`::  Kilo
`m`::  Mega
`g`::  Giga
`t`::  Tera
`p`::  Peta

[[distance-units]]
[float]
=== 距离单位

当需要指定距离时，例如 <<query-dsl-geo-distance-query>> 里的 `distance` 参数，
如果没有指定则默认单位为米。可以指定其他距离单位，例如 `"1km"` 或 `"2mi"` （2 英里）。

所有的完整单位列表列举如下：

[horizontal]
Mile::          `mi` or `miles`
Yard::          `yd` or `yards`
Feet::          `ft` or `feet`
Inch::          `in` or `inch`
Kilometer::     `km` or `kilometers`
Meter::         `m` or `meters`
Centimeter::    `cm` or `centimeters`
Millimeter::    `mm` or `millimeters`
Nautical mile:: `NM`, `nmi` or `nauticalmiles`

[[fuzziness]]
[float]
=== 模糊性

一些查询和 APIs 允许使用 `fuzziness` 参数进行非精确 _fuzzy_ 匹配。

当查询 `text` 或 `keyword` 字段，`fuzziness` 解释为 http://en.wikipedia.org/wiki/Levenshtein_distance[Levenshtein Edit Distance] --
 两个字符串转换时所需的最少字符改变数。

可以指定的 `fuzziness` 参数有：

`0`, `1`, `2`::

最大允许 Levenshtein Edit Distance（或编辑数）

`AUTO`::
+
--
根据词项的长度生成编辑距离。
可以选择低距离和高距离参数 `AUTO:[low],[high]` ，如果没有指定，默认值为 3 和 6，等同于 `AUTO:3,6` ：

`0..2`:: must match exactly
`3..5`:: one edit allowed
`>5`:: two edits allowed

`AUTO` 一般应该是 `fuzziness` 的首选值。
--

[float]
[[common-options-error-options]]
=== 启用堆栈追踪

Elasticsearch 默认不会在请求返回错误时包含堆栈错误。你可以通过在 url 参数中设置 `error_trace` 为 `true` 启用该行为。
例如，默认情况下你向 `_search` API 添加无效的 `size` 参数：

[source,js]
----------------------------------------------------------------------
POST /twitter/_search?size=surprise_me
----------------------------------------------------------------------
// CONSOLE
// TEST[s/surprise_me/surprise_me&error_trace=false/ catch:bad_request]
// Since the test system sends error_trace=true by default we have to override

类似的响应如下：

[source,js]
----------------------------------------------------------------------
{
  "error" : {
    "root_cause" : [
      {
        "type" : "illegal_argument_exception",
        "reason" : "Failed to parse int parameter [size] with value [surprise_me]"
      }
    ],
    "type" : "illegal_argument_exception",
    "reason" : "Failed to parse int parameter [size] with value [surprise_me]",
    "caused_by" : {
      "type" : "number_format_exception",
      "reason" : "For input string: \"surprise_me\""
    }
  },
  "status" : 400
}
----------------------------------------------------------------------
// TESTRESPONSE

但是如果你设置 `error_trace=true`:

[source,js]
----------------------------------------------------------------------
POST /twitter/_search?size=surprise_me&error_trace=true
----------------------------------------------------------------------
// CONSOLE
// TEST[catch:bad_request]

类似的响应如下：

[source,js]
----------------------------------------------------------------------
{
  "error": {
    "root_cause": [
      {
        "type": "illegal_argument_exception",
        "reason": "Failed to parse int parameter [size] with value [surprise_me]",
        "stack_trace": "Failed to parse int parameter [size] with value [surprise_me]]; nested: IllegalArgumentException..."
      }
    ],
    "type": "illegal_argument_exception",
    "reason": "Failed to parse int parameter [size] with value [surprise_me]",
    "stack_trace": "java.lang.IllegalArgumentException: Failed to parse int parameter [size] with value [surprise_me]\n    at org.elasticsearch.rest.RestRequest.paramAsInt(RestRequest.java:175)...",
    "caused_by": {
      "type": "number_format_exception",
      "reason": "For input string: \"surprise_me\"",
      "stack_trace": "java.lang.NumberFormatException: For input string: \"surprise_me\"\n    at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)..."
    }
  },
  "status": 400
}
----------------------------------------------------------------------
// TESTRESPONSE[s/"stack_trace": "Failed to parse int parameter.+\.\.\."/"stack_trace": $body.error.root_cause.0.stack_trace/]
// TESTRESPONSE[s/"stack_trace": "java.lang.IllegalArgum.+\.\.\."/"stack_trace": $body.error.stack_trace/]
// TESTRESPONSE[s/"stack_trace": "java.lang.Number.+\.\.\."/"stack_trace": $body.error.caused_by.stack_trace/]

[float]
=== 查询字符串中的请求体

对于非 POST 请求不接受请求体的库，你可以将请求体作为 `source` 查询字符串参数替换。
当使用该方法时，`source_content_type` 参数应该传递指示 source 格式的媒体类型值传递，例如 `application/json` 。

[float]
=== Content-Type 要求

请求体中的内容类型必须使用 `Content-Type` 头指定。这个头必须映射成 API 支持的格式。
大多数 APIs 支持 JSON、YAML、CBOR 和 SMILE。
批操作和 multi-search APIs 支持 NDJSON、JSON 和 SMILE；
其他类型会导致响应错误。

另外，当使用 `source` 查询字符串参数时，内容类型必须使用 `source_content_type` 查询字符串参数指定。

[[url-access-control]]
== 基于 URL 的访问控制

很多用户使用基于 URL 访问控制的代理来安全地访问 Elasticsearch 索引。对于 <<search-multi-search,multi-search>> 、
<<docs-multi-get,multi-get>> 和  <<docs-bulk,bulk>> 请求，用户可以选择在 URL 和每个请求体的独立请求上指定索引。
这可能使得基于 URL 的访问控制具有挑战性。

为了阻止用户覆盖指定 URL 中的索引，可以在 `elasticsearch.yml` 文件中添加并设置：

    rest.action.multi.allow_explicit_index: false

默认值为 `true` ，但是当设置为 `false` 时，Elasticsearch 将拒绝在请求体中显式指定索引的请求。
