[[docs-get]]
== Get API

get API 允许从一个根据 id 的索引中获取一个 JSON 格式的文档。
下例从 twitter 索引 _doc 类型下获取 id 为 0 的 JSON 文档：

[source,js]
--------------------------------------------------
GET twitter/_doc/0
--------------------------------------------------
// CONSOLE
// TEST[setup:twitter]

上文 get 操作的结果是：

[source,js]
--------------------------------------------------
{
    "_index" : "twitter",
    "_type" : "_doc",
    "_id" : "0",
    "_version" : 1,
    "found": true,
    "_source" : {
        "user" : "kimchy",
        "date" : "2009-11-15T14:12:12",
        "likes": 0,
        "message" : "trying out Elasticsearch"
    }
}
--------------------------------------------------
// TESTRESPONSE

上文结果包含我们想要获取文档的 `_index` 、 `_type` 、 `_id` 和 `_version` ，
包括文档的实际 `_source` ，如果它可以被发现（响应中的 `found` 字段）。

API 同意允许使用 `HEAD` 验证文档是否存在，例如：

[source,js]
--------------------------------------------------
HEAD twitter/_doc/0
--------------------------------------------------
// CONSOLE
// TEST[setup:twitter]

[float]
[[realtime]]
=== 实时

默认情况，get API 是实时的，并不受索引 refresh 频率（当数据对搜索可见）的影响。
如果一个文档被更新且并没有 refresh，get API 将立即执行 refresh 调用使文档可见。
这同样会使从上次 refresh 后改变的文档可见。如果需要禁止实时 GET，可以设置 `realtime` 参数为 `false` 。

[float]
[[get-source-filtering]]
=== Source 过滤

默认情况，除非使用 `stored_fields` 参数或禁用 `_source` ，否则 get 操作会返回 `_source` 字段内容。
你可以使用 `_source` 参数来关闭 `_source` 检索：

[source,js]
--------------------------------------------------
GET twitter/_doc/0?_source=false
--------------------------------------------------
// CONSOLE
// TEST[setup:twitter]

如果只需 `_source` 中的一两个字段，你可以使用 `_source_include` & `_source_exclude` 参数来包含或者过滤你需要的部分。
这对获取大文档的部分字段十分有用，可以节省网络负载。这两个参数都可以用逗号分隔符连接或者通配符表达式。示例：

[source,js]
--------------------------------------------------
GET twitter/_doc/0?_source_include=*.id&_source_exclude=entities
--------------------------------------------------
// CONSOLE
// TEST[setup:twitter]

如果你只想指定 includes，你可以使用更简短的表示方法：

[source,js]
--------------------------------------------------
GET twitter/_doc/0?_source=*.id,retweeted
--------------------------------------------------
// CONSOLE
// TEST[setup:twitter]

[float]
[[get-stored-fields]]
=== Stored Fields

get 操作允许通过 `stored_fields` 参数返回指定的 stored fields 集。
如果请求字段没有 stored，它们会被忽略。可以参考以下示例：

[source,js]
--------------------------------------------------
PUT twitter
{
   "mappings": {
      "_doc": {
         "properties": {
            "counter": {
               "type": "integer",
               "store": false
            },
            "tags": {
               "type": "keyword",
               "store": true
            }
         }
      }
   }
}
--------------------------------------------------
// CONSOLE

现在我们添加一个文档：

[source,js]
--------------------------------------------------
PUT twitter/_doc/1
{
    "counter" : 1,
    "tags" : ["red"]
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

... 尝试获取它：

[source,js]
--------------------------------------------------
GET twitter/_doc/1?stored_fields=tags,counter
--------------------------------------------------
// CONSOLE
// TEST[continued]

以上 get 操作的结果是：

[source,js]
--------------------------------------------------
{
   "_index": "twitter",
   "_type": "_doc",
   "_id": "1",
   "_version": 1,
   "found": true,
   "fields": {
      "tags": [
         "red"
      ]
   }
}
--------------------------------------------------
// TESTRESPONSE


从文档抓取的 Field 值常常以数组形式返回。因为 `counter` 字段没有被存储，尝试获取 `stored_fields` 时 get 请求简单的忽略它。

可以获取类似 `_routing` 的元字段：

[source,js]
--------------------------------------------------
PUT twitter/_doc/2?routing=user1
{
    "counter" : 1,
    "tags" : ["white"]
}
--------------------------------------------------
// CONSOLE
// TEST[continued]

[source,js]
--------------------------------------------------
GET twitter/_doc/2?routing=user1&stored_fields=tags,counter
--------------------------------------------------
// CONSOLE
// TEST[continued]

以上 get 操作的结果是：

[source,js]
--------------------------------------------------
{
   "_index": "twitter",
   "_type": "_doc",
   "_id": "2",
   "_version": 1,
   "_routing": "user1",
   "found": true,
   "fields": {
      "tags": [
         "white"
      ]
   }
}
--------------------------------------------------
// TESTRESPONSE

同样只有叶子字段可以通过 `stored_field` 选项返回。所以无法返回 object 字段同时这个请求会失败。

[float]
[[_source]]
=== 直接 Getting the +_source+

使用 `/{index}/{type}/{id}/_source` endpoint 可以只 get 文档的 `_source` 字段，
不会有其他附加内容。例如：

[source,js]
--------------------------------------------------
GET twitter/_doc/1/_source
--------------------------------------------------
// CONSOLE
// TEST[continued]

你同样可以使用相同的 source 过滤参数来控制 `_source` 返回的部分：

[source,js]
--------------------------------------------------
GET twitter/_doc/1/_source?_source_include=*.id&_source_exclude=entities'
--------------------------------------------------
// CONSOLE
// TEST[continued]

注意， HEAD 变量同样可以有效验证 _source 是否存在。
一个已存在的文档如果在 <<mapping-source-field,mapping>> 已禁止，那么不会有 _source 。

[source,js]
--------------------------------------------------
HEAD twitter/_doc/1/_source
--------------------------------------------------
// CONSOLE
// TEST[continued]

[float]
[[get-routing]]
=== 路由

当索引时使用了控制路由功能，为了 get 文档，需要提供路由值。例如：

[source,js]
--------------------------------------------------
GET twitter/_doc/2?routing=user1
--------------------------------------------------
// CONSOLE
// TEST[continued]

以上操作将 get id 为 2 的 tweet，但是基于 user 路由的。
注意，如果 get 没有正确路由，将造成文档无法被获取。

[float]
[[preference]]
=== Preference

控制分片执行 get 请求的 `preference` 。默认是随机在分片见执行的。

`preference` 可以设置为：

`_primary`::
	操作会在主分片上执行。

`_local`::
  如果可能优先在本地分片执行。

Custom (string) value::
  自定义值会确保相同分片使用相同自定义值。这可以用 "jumping values" 帮助不同 refresh 状态下命中不同分片。
  这个值可以是 session id 或 user name。

[float]
[[get-refresh]]
=== Refresh

`refresh` 参数可以设置为 `true` 为了在 get 操作和可搜索前 refresh 相关分片。
设置 `true` 应该十分小心并需要验证这不会对系统造成过载（降低索引速度）。

[float]
[[get-distributed]]
=== Distributed

get 操作将 hash 至指定分片 id。然后它直接从包含该分片 id 的某个 replicas 中返回结果。
replicas 是分片 id 组内的主分片和副本分片。这意味我们 replicas 更多， get 扩展能力更强。


[float]
[[get-versioning]]
=== 版本支持

当前版本与指定版本相等时你可以使用 `version` 参数获取文档。除了经常获取文档的 `FORCE` 版本类型，
这种方式与 all 版本类型相同。注意 `FORCE` 版本类型已过期。

Elasticsearch 内部标记旧文档为删除并添加一个新文档。文档的旧版本不会直接消失，尽管你无法访问它。
Elasticsearch 在你继续索引更多数据时会在后台清理已删除文档。
