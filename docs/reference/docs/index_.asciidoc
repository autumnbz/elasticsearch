[[docs-index_]]
== Index API

IMPORTANT: 请参考 <<removal-of-types>>.

index API 通过向指定索引中输入一个 JSON 文档来添加或更新，使文档变得可搜索。
下例将 JSON 文档插入到叫 "twitter" 索引中，id 为 1 的 "_doc" 类型：

[source,js]
--------------------------------------------------
PUT twitter/_doc/1
{
    "user" : "kimchy",
    "post_date" : "2009-11-15T14:12:12",
    "message" : "trying out Elasticsearch"
}
--------------------------------------------------
// CONSOLE

上述索引操作结果如下：

[source,js]
--------------------------------------------------
{
    "_shards" : {
        "total" : 2,
        "failed" : 0,
        "successful" : 2
    },
    "_index" : "twitter",
    "_type" : "_doc",
    "_id" : "1",
    "_version" : 1,
    "_seq_no" : 0,
    "_primary_term" : 1,
    "result" : "created"
}
--------------------------------------------------
// TESTRESPONSE[s/"successful" : 2/"successful" : 1/]

`_shards` 头提供了有关索引操作复制进程的信息：

* `total` - 表明多少分片副本（主分片和复制分片）执行索引操作。
* `successful`- 表明成功执行索引操作分片副本数。
* `failed` - 存在失败的情况下会返回一个操作失败的分片数组列表。

`successful` 至少为 1 时索引操作才会成功。

NOTE:   索引操作返回成功时，复制分片有可能还没全部启动（默认情况下，只需要主分片，但是这个行为可以 <<index-wait-for-active-shards,修改>> ）。
        在这个场景中，`total` 等于基于 `number_of_replicas` 设置的所有分片数，`successful` 将会等于已启动的分片数（主分片加复制分片）。
        如果没有失败，`failed` 会为 0。

[float]
[[index-creation]]
=== 自动创建索引

如果索引没有创建，那么索引操作将自动创建索引（查看手动创建索引 <<indices-create-index,create index API>> ），
如果类型没有创建（查看手动创建类型 <<indices-put-mapping,put mapping>> API），并会自动创建一个动态类型映射用于指定类型。

映射本身是十分灵活和无模式的。新字段和对象会自动添加到指定类型的映射定义中。
更多映射定义请查看 <<mapping,mapping>> 章节。

自动创建索引可以通过设置所有节点配置文件中的 `action.auto_create_index` 为 `false` 禁用。
自动创建映射可以通过设置每个索引的 `index.mapper.dynamic` 为 `false` 禁用。

自动创建索引可以包含基于黑白名单列表的模式。例如，设置 `action.auto_create_index` 为 `+aaa*,-bbb*,+ccc*,-*` （+ 意味着允许，- 意味着不允许）。

[float]
[[index-versioning]]
=== 版本

每个已索引的文档都有一个版本数值。相关的 `version` 值作为索引 API 请求的响应中的一部分返回。
索引 API 选项允许指定 `version` 参数时 http://en.wikipedia.org/wiki/Optimistic_concurrency_control[optimistic
concurrency control] 。这将控制其执行操作文档的版本。一个使用场景中用版本控制的好的例子是执行 read-then-update 事务。
从初始读取的文档指定 `version` 可以确保此期间不会有改变（当读取是用于更新时，建议设置 `preference` 为 `_primary`）。例如：

[source,js]
--------------------------------------------------
PUT twitter/_doc/1?version=2
{
    "message" : "elasticsearch now has versioning support, double cool!"
}
--------------------------------------------------
// CONSOLE
// TEST[continued]
// TEST[catch: conflict]

*NOTE:* 版本控制是实时的，并且不受搜索操作的近实时影响。没有没有提供版本，则操作执行时不会校验任何版本。

默认情况下，内部版本号以 1 开始并在每次更新时自增，包括删除。可选地，版本号可以以外部值（例如由数据库维护）补充。
为了启用该功能，`version_type` 必须设置为 `external` 。提供的值必须为数值，大于或等于 0 且小于 9.2e+18 的 long 值。
当使用外部版本类型，系统检查传递给索引请求的版本号是否大于当前存储文档的版本，而不是检查匹配的版本号。
如果为 true，文件将会被索引同时新版本号会被使用。如果提供的值小于或等于已存储的版本号，会发生版本冲突同时索引操作将失败。

WARNING: 外部版本号支持 0 作为有效版本号。这允许版本号与外部版本系统同步，其中版本号从 0 开始而不是 1。
它的副作用是，版本号为 0 的文档既不能使用  <<docs-update-by-query,Update-By-Query API>> 更新也不能使用
<<docs-delete-by-query,Delete By Query API>> 删除。

一个好的作用是，只要使用源数据库的版本号，不需维护执行异步索引操作源数据库结果的改变的严格排序。
如果使用外部版本控制，即使是使用数据更新 Elasticsearch 索引的简单场景都将将简化，因为无论索引操作因何原因无序都只使用最新版本。

[float]
==== 版本类型

紧接着上文解释的 `internal` & `external` 版本类型，Elasticsearch 还支持特定用例的其他类型。
这里是不同版本类型和语义的概括。

`internal`:: 仅在给定版本与存储文档的版本相同时才索引文档。

`external` or `external_gt`:: 仅在给定版本严格高于存储文档的版本  *或* 文档不存在时才索引文档。给定的版本将作为最新版本并与新文档一起存储。提供的版本必须是非负 long 值。

`external_gte`:: 仅在给定版本 *等于* 或高于存储文档的版本时才索引文档。如果文档不存在操作也会成功。
给定的版本将作为最新版本并与新文档一起存储。提供的版本必须是非负 long 值。

*NOTE*: `external_gte` 版本类型适用于特殊场景并应谨慎使用。如果使用不正确可能导致数据丢失。
这有另一个 `force` 选项，这个选项已经弃用因为它可能造成主分片和副本分片不一致。

[float]
[[operation-type]]
=== 操作类型

索引操作同样接收用于强制 `create` 操作的 `op_type` ，允许 "put-if-absent" 行为。
当使用 `create` ，如果文档 id 已在索引中存在则索引操作将失败。

以下是一个使用 `op_type` 参数的例子：

[source,js]
--------------------------------------------------
PUT twitter/_doc/1?op_type=create
{
    "user" : "kimchy",
    "post_date" : "2009-11-15T14:12:12",
    "message" : "trying out Elasticsearch"
}
--------------------------------------------------
// CONSOLE

指定 `create` 的另一个选择是使用以下 uri：

[source,js]
--------------------------------------------------
PUT twitter/_doc/1/_create
{
    "user" : "kimchy",
    "post_date" : "2009-11-15T14:12:12",
    "message" : "trying out Elasticsearch"
}
--------------------------------------------------
// CONSOLE

[float]
=== 自动 ID 生成

可以不指定 id 执行索引操作。这时会自动生成 ID。另外，`op_type` 将自动设为 `create` 。
下面是一个例子（注意使用 *POST* 替换 *PUT*）：

[source,js]
--------------------------------------------------
POST twitter/_doc/
{
    "user" : "kimchy",
    "post_date" : "2009-11-15T14:12:12",
    "message" : "trying out Elasticsearch"
}
--------------------------------------------------
// CONSOLE

以上索引操作结果是：

[source,js]
--------------------------------------------------
{
    "_shards" : {
        "total" : 2,
        "failed" : 0,
        "successful" : 2
    },
    "_index" : "twitter",
    "_type" : "_doc",
    "_id" : "6a8ca01c-7896-48e9-81cc-9f70661fcb32",
    "_version" : 1,
    "_seq_no" : 0,
    "_primary_term" : 1,
    "result": "created"
}
--------------------------------------------------
// TESTRESPONSE[s/6a8ca01c-7896-48e9-81cc-9f70661fcb32/$body._id/ s/"successful" : 2/"successful" : 1/]

[float]
[[index-routing]]
=== 路由

默认，分片位置 — 或 `routing` — 由文档 id 值的 hash 控制。对于显式控制，
传递给 hash 函数用于路由的值可以基于每个操作直接指定使用 `routing` 参数。例如：

[source,js]
--------------------------------------------------
POST twitter/tweet?routing=kimchy
{
    "user" : "kimchy",
    "post_date" : "2009-11-15T14:12:12",
    "message" : "trying out Elasticsearch"
}
--------------------------------------------------
// CONSOLE

上例中，"_doc" 文档基于 `routing` 参数提供的 "kimchy" 路由到相应分片。

当显式设置 mapping，可以选择使用 `_routing` 字段来指示索引操作从文档本身提取路由值。
这确实是以（非常小的）成本来实现的额外的文件解析过程。如果定义 `_routing` 映射并设置为 `required` ，
索引操作在没有提供路由值时会失败。

[float]
[[index-distributed]]
=== 分布式

索引操作基于路由定位到主分片（查看上文的路由章节），
并在包含此分片的实际节点上执行。在主分片完成操作后，如果需要，该更新将分发至适用的副本分片。

[float]
[[index-wait-for-active-shards]]
=== 等待活动分片

为了提高写入系统的弹性，索引操作可以配置为在继续处理操作前等待一定数量的活动分片副本。
如果所需的活动分片副本数不可用，那么写操作必须等待重试，直至必须的分片副本启动或超时。
默认情况，写操作在执行前只等待主分片成为活动分片（例如  `wait_for_active_shards=1` ）。
默认值可以在索引设置中动态设置 `index.write.wait_for_active_shards` 覆盖。
为了改变每个操作的行为，可以使用 `wait_for_active_shards` 请求参数。

有效值是 `all` 或任何到每个索引分片的配置副本总数（即 `number_of_replicas+1`）。
指定负值或大于分片副本数都将抛出错误。

例如，假设我们有一个三节点组成的集群， `A` 、 `B` 和 `C` ，
同时我们创建复制数为 3 (4 个分片副本，多于节点数的副本个数) 索引名为 `index` 的索引。
如果我们尝试索引操作，默认情况执行操作前只保证主分片可用。这意味着即使 `B` 和 `C` 离开，
`A` 拥有主分片，索引操作仍将在只有一个副本的情况下执行。如果 `wait_for_active_shards` 设置为 `3` （所有节点都正常），
那么索引操作在执行前需要 3 个活动分片，因为集群有 3 个活动节点所有这是应该满足的需求，每个节点拥有一个分片。
然而，如果我们设置 `wait_for_active_shards` 为 `all` （或者是 `4` ，结果一样），索引操作将不会继续，
因为索引中的每个活动分片无法拥有 4 个副本。该操作将超时，除非在集群中引入新节点来存储第四个副本分片。

需要尤其注意的是，这个设置极大地降低了写操作不写所需分片副本的机会，但是它无法完全消除这种可能性，因为
这种检查发生在写操作之前。一旦正在进行写操作，在任何分片副本都可能出现复制失败但是主分片仍然成功。
`_shards` 章节的写操作响应显示了 成功/失败 复制的分片副本数。

[source,js]
--------------------------------------------------
{
    "_shards" : {
        "total" : 2,
        "failed" : 0,
        "successful" : 2
    }
}
--------------------------------------------------
// NOTCONSOLE

[float]
[[index-refresh]]
=== Refresh

控制所做的请求更改何时对搜索可见。请参考 <<docs-refresh,refresh>>

[float]
[[index-noop]]
=== Noop Updates

当使用索引 api 更新文档时，即使文档并没有改变，新版本的文档总会创建。如果这不能接受，
使用 `_update` api 时设置 `detect_noop` 为 true。这个选项在 index api 时不可用因为 index api
不能提取 old source，并且无法与 new source 比较。

当 noop 更新是不能接受时没有一个强制且快速的规则。它由很多因素组成，
例如数据源发送更新的实际 noops 频率，以及每秒由多少查询，Elasticsearch 在哪个分片接收更新。

[float]
[[timeout]]
=== 超时

索引操作时分配执行的主分片可能不可用。一些原因可能是主分片当前正从网关恢复或正进行迁移。
默认情况下，索引操作将在主分片上最多等待 1 分钟，
之后会失败并响应错误。
`timeout` 参数可以显式指定等待时间。以下将其设置为 5 分钟：

[source,js]
--------------------------------------------------
PUT twitter/_doc/1?timeout=5m
{
    "user" : "kimchy",
    "post_date" : "2009-11-15T14:12:12",
    "message" : "trying out Elasticsearch"
}
--------------------------------------------------
// CONSOLE
