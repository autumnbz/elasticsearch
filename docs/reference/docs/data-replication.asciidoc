
[[docs-replication]]
== 读写文档

[float]
=== 引言

Elasticsearch 中的每个索引都 <<getting-started-shards-and-replicas,分为分片>> ，同时每个分片可以具有多个副本。这些副本被称为 _复制组_ ，并且在添加或删除
文档时必须保持同步。如果我们不这样做，将导致一个副本与另一副本读取到不同的结果。
保持分片副本同步并提供读操作的过程就是我们所说的 _数据复制模型_ 。

Elasticsearch 的数据复制模型是基于 _主备模型_ ，
该模型在微软研究院的 https://www.microsoft.com/en-us/research/publication/pacifica-replication-in-log-based-distributed-storage-systems/[PacificA 论文] 中
有很好的描述。主备模型基于复制组中的单个副本充当主分片。其他副本称为 _副本分片_ 。主分片作为所有索引操作的主入口。它负责验证这些操作并保证它们是正确的。一旦一个索引操作
被主分配接受，主分片同样负责将操作负责到其他副本。

本章的目的是对 Elasticsearch 复制模型进行高度概述，并讨论读写操作之间的各种交互意义。

[float]
=== 基本写模型

Elasticsearch 中的每个索引操作首先会被 <<index-routing,routing>> 解析至复制组，通常基于文档 ID。一旦确定复制组，操作将在内部转发到复制组的当前 _主分片_ 。
主分片负责验证操作并将操作转发至其他副本。因为副本可能离线，主分片不需要复制操作到所有副本。Elasticsearch 维护了一个可接收操作的分片副本列表。
这个列表被称为 _in-sync copies_ ，并由主节点维护。顾名思义，
这些节点是一个 "good" 分片副本集，该集合确保所有已处理的索引和删除操作都已被用户确认。
主分片负责维护这个不变性，因此必须复制所有操作到这个集合中的每个副本。

主分片遵循以下基本流程：

. 验证传入的操作并在结构无效时拒绝它（例如：期望数值却传入对象字段）
. 执行本地操作 例如 索引或删除相关文档。这同样会延展字段内容并在需要时拒绝（例如：Lucene 索引时 keyword 值太长）。
. 在同步复制集中转发操作至每个副本。如果有多个副本，转发是并行执行的。
. 一旦所有副本成功执行操作并对主分片作出响应，主分片确认成功地完成客户端请求。

[float]
==== 失败处理

索引时很多情形可能导致错误 -- 磁盘损坏，节点间失联，或者一些配置错误导致即使主分片成功但是副本操作失败。这些情况很少发生，但是主分片必须对其作出响应。

如果主分片自身失败，拥有主分片的节点将向主节点发送失败消息。
索引操作将等待（最多 1 分钟，通过 <<dynamic-index-settings,default>> ）直至主节点将一个副本提升为新的主分片。
操作将会转发到新主节点执行。需要注意注意的是主节点同样会监控节点健康，并可能绝对主动降级为主节点。典型场景发生在
主分片节点遇到网络错误时与集群断开。更多细节请参考 <<demoted-primary,这里>> 。

一旦操作至主分片成功执行，主分片必须处理在副本分片上执行操作时的潜在失败。
这可能是由于副本实际失败或者网络错误造成操作未到达副本造成的（或未从副本响应）。
所有这些得到相同结果：同步副本集中的一个副本丢失本该被确认的操作。未了避免违反约点，主分片会向主节点发送将问题分片从同步副本集移除的消息。
只有确认主节点移除分片，主分片才会确认该操作。需要注意的是主节点同样会指示其他节点开始构建一个新分片，最终使系统恢复健康状态。

[[demoted-primary]]
当转发操作到副本时，主分片会使用副本来验证它们仍然是活跃的主分片。如果主分片因为网络分区（或者长时间 GC）隔离，在发现被降级前它仍将
处理到达的索引操作。从过时主分片抵达的操作会被副本拒绝。当主分片接收到副本因其不再是主分片而回复的拒绝响应时，它会与主分片握手并发现已被替换。
操作将路由到新的主节点。

.没有副本时将发生什么？
************
索引配置或者仅仅因为副本失败可能发生该情景。在这种境况下，主分片将不进行任何外部校验情况下处理操作，这看起来可能由问题。
另一方面，主分片无法自己使其他分片失败，除了向主节点发送请求。这意味着主节点知道主分片是唯一的好备份。
因为我们保证主节点不会提升任何其他（过时）分片复制为新主节点，因为不会丢失任何主节点索引操作。当然，因为那时我们只运行一次数据，物理硬件问题可能
导致数据丢失。更多缓解选项请参考 <<index-wait-for-active-shards>> 。
************

[float]
=== 基本读模型

Elasticsearch 读可以是通过 ID 轻量级地查找，也可以是利用高 CPU 进行复杂聚合的重量级搜索请求。
主备模型的一个优点是他可以保证所有分片副本一致（in-flight 操作除外）。因此，单同步副本足以满足读请求。

当节点接受读请求，节点负责转发请求至持有相关分片的节点，整理响应并响应至客户端。我们称该节点为请求 _协调节点_ 。基本流程如下：

. 解析读请求至相关分片。注意因为大多数搜索会发送至一个或多个索引，他们一般需要从多个分片读取，每个代表不同的数据子集。
. 从分片复制组相关分片中选择一个活动副本。这可以是主分片或者副本分片。默认，Elasticsearch 将在分片之间轮训。
. 将分片级读请求发送至选中副本。
. 组合结果并响应。注意 ID 查找时只有一个相关分片，因此可跳过该步。

[float]
==== 失败处理

当分片响应读请求失败，协调节点将从复制组中选择另一个分片并向其分送分片级搜索。重复失败可能导致没有分片可用。
在一些场景下，例如 `_search` ，Elasticsearch 倾向于快速响应，用部分结果替代而不是等待解决错误（部分结果会在 `_shards` 响应头指明）。

[float]
=== 一些简单含义

Each of these basic flows determines how Elasticsearch behaves as a system for both reads and writes. Furthermore, since read
and write requests can be executed concurrently, these two basic flows interact with each other. This has a few inherent implications:
每一个基本流程都决定了 Elasticsearch 作为读写系统如何操作。此外，因为读写请求可以同时执行，这两个基本流程可互相交互。这有几个固有的含义：

高效读:: 正常操作下，每个相关复制组执行一次读取操作。
   只有在失败情况下，同一个分片的多个副本才会执行相同的搜索。

读不确认:: 由于主分片首先在本地索引，然后复制请求，因此并发读可能在已确认之前看到已做的更改。

默认两个副本:: 该模型可以容错，同时只保留两个数据副本。这与 quorum-based 相反，其中容错的最小副本数为 3。

[float]
=== 失败

失败时，以下是可能的：

一个分片可能降低索引速度:: 因为主分片在每个操作时需要等待所有同步副本，因此一个慢分片可能会降低整个复制组速度。
  这是我们为上文提到的高效读付出的代价。当然，一个慢分片也会降低不幸路由到它的搜索。

脏读:: 一个隔离的主节点可能出现未确认写。这是因为一个隔离主节点只在向副本发送请求或与主节点交互时才能发现它已被隔离。此时操作已被主分片索引并可以并发读。
  Elasticsearch 缓解这种风险的方式是每秒（默认）与主节点 ping，并在没有主节点时拒绝索引操作。

[float]
=== 冰山一角

该文档提供了 Elasticsearch 如果处理数据的高级概括。当然，还有很多在后台的东西。比如主要词项、发布集群状态和主选举等都在保证系统正确运行发挥了作用。
这个文档也不覆盖已知的和重要 bugs（包括已关闭和打开）。我们认识到 https://github.com/elastic/elasticsearch/issues?q=label%3Aresiliency[GitHub 很难齐头并进] 。
未了帮助大家保持最佳状态，我们在网站 https://www.elastic.co/guide/en/elasticsearch/resiliency/current/index.html[resiliency page] 保持专注。
我们强烈建议阅读它。
